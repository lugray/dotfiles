#!/opt/homebrew/opt/ruby/bin/ruby --disable-gems

ITALIC = 3
RED = 31
YELLOW = 33
CYAN = 36
GREY = 90
BOLD_GREEN = 92
BOLD_MAGENTA = 95
ORANGE = '38;5;208'

def cycle(*array)
  array[ARGV[1].to_i % array.size]
end

def theme
  @theme ||= begin
    if Time.now.strftime("%m").to_i == 12
      {
        machine: BOLD_GREEN,
        path: RED,
        branch: BOLD_GREEN,
        prefix: RED,
        success_emoji: cycle('ðŸŽ„', 'ðŸŽ…', 'ðŸŽ', 'ðŸ¤¶', 'â›„', 'ðŸ¦Œ', 'â„ï¸', 'â˜ƒï¸'),
        failure_emoji: 'ðŸª¨',
      }
    elsif Time.now.strftime("%m").to_i == 10 && Time.now.strftime("%d").to_i >= 25
      {
        machine: ORANGE,
        path: YELLOW,
        branch: ORANGE,
        prefix: ORANGE,
        success_emoji: cycle('ðŸŽƒ', 'ðŸ‘»', 'ðŸ•·ï¸', 'ðŸ§™â€â™€ï¸', 'ðŸ§›â€â™‚ï¸', 'ðŸ§Ÿâ€â™‚ï¸', 'ðŸ¦‡', 'ðŸ¬', 'ðŸ•¸ï¸'),
        failure_emoji: cycle('ðŸ’€', 'ðŸª¦', 'â˜ ï¸'),
      }
    else
      {
        machine: GREY,
        path: CYAN,
        branch: BOLD_MAGENTA,
        prefix: nil,
        success_emoji: 'ðŸ™',
        failure_emoji: 'ðŸ¤¬',
      }
    end
  end
end

def format(code, text)
  return text unless code
  "%{\x1b[#{code}m%}#{text}%{\x1b[0m%}"
end

def part(data, symbol, color = nil)
  return '' if data == 0
  format(color, "#{symbol}#{data}")
end

def machine
  require 'socket'
  name = Socket.gethostname
  name = '%2{ðŸŒ±%} Fullscript' if name == 'CA-GYQQJMHGPK'
  format(theme[:machine], format(ITALIC, name))
end

def path
  pwd = Dir.pwd
  home = ENV['HOME']
  prefix_replace = {
    "#{home}/src/git.fullscript.io" => 'ïŠ– ',
    "#{home}/src/github.com" => 'ï‚› ',
    home => '~',
  }
  prefix_replace.each do |prefix, replacement|
    pwd = pwd.sub(prefix, replacement) if pwd.start_with?(prefix)
  end
  format(theme[:path], pwd)
end

def format_prefix(prefix)
  format(theme[:prefix], prefix)
end

def print_prompt(suffix = "", final: false)
  print "#{format_prefix('â•­â”€')}#{machine} #{path}#{suffix}\n" \
    "#{format_prefix('â•°â”€')}%(?.%2{#{theme[:success_emoji]}%}.#{format(RED, '[%?]')} %2{#{theme[:failure_emoji]}%}) "
  exit 0 if final

  print "\0"
  $stdout.flush
end

print_prompt

require 'open3'

def git_part
  porcelain, _err, stat = Open3.capture3('git', 'status', '--porcelain=v2', '--show-stash', '--branch')
  return "" unless stat.success?

  info = porcelain.each_line.each_with_object(Hash.new(0)) do |line, h|
    case line
    when /^# branch\.oid (.*)/
      h[:oid] = $1
    when /^# branch\.head (.*)/
      h[:branch] = $1
    when /^# branch\.ab \+(\d+) -(\d+)/
      h[:ahead] = $1.to_i
      h[:behind] = $2.to_i
    when /^# stash (\d+)/
      h[:stashed] = $1.to_i
    when /^[12] (.)(.)/
      h[:staged] += 1 if $1 != '.'
      h[:changed] += 1 if $2 != '.'
    when /^u/
      h[:conflicts] += 1
    when /^\?/
      h[:untracked] += 1
    end
  end

  info[:branch] = ":#{info[:oid][0..6]}" if info[:branch] == '(detached)' || info[:branch] == 0
  info[:clean] = '' if info[:staged] + info[:conflicts] + info[:changed] + info[:untracked] == 0

  status = [
    ' [',
    part(info[:branch],    '',        theme[:branch]),
    '|',
    part(info[:behind],    'â†“'),
    part(info[:ahead],     'â†‘'),
    part(info[:staged],    '%2{ðŸŽ­%}', RED),
    part(info[:conflicts], '%2{ðŸ’¥%}', RED),
    part(info[:changed],   '%2{ðŸš§%}', YELLOW),
    part(info[:untracked], '%2{ðŸ†•%}', CYAN),
    part(info[:stashed],   '%2{ðŸ“¦%}', YELLOW),
    part(info[:clean],     'îœ¦',       BOLD_GREEN),
    ']',
  ].join('')

  status
end

def sso_part
  return "" unless ENV['UGRAY_SHOW_SSO_STATUS'] == '1'
  out, _err, stat = Open3.capture3('/opt/fullscript/bin/rx', 'sso', 'status', '-i', '1', '-o', '2')
  if stat.success?
    if out.chomp == '1'
      sso_part = format(GREY, ' [SSO ok]')
    elsif out.chomp == '2'
      sso_part = format(RED, ' [SSO expired]')
    else
      sso_part = "--#{out.chomp}--"
    end
  else
    sso_part = format(RED, " [SSO?]")
  end
end

def print_with_prefixes(*methods)
  wait_queue = Thread::Queue.new
  results = {}
  methods.each do |method|
    Thread.new { results[method] = send(method) ; wait_queue.push(true) }
  end
  methods.size.times do |i|
    wait_queue.pop
    print_prompt(results.values_at(*methods).join, final: i == methods.size - 1)
  end
end

print_with_prefixes(:git_part, :sso_part)
